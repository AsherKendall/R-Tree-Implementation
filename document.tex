\documentclass{article}
\usepackage{tikz}
\author{Asher Griess, David Medin}
\title{R Tree Algorithm}
\begin{document}
\maketitle

\section{Abstract}
An R Tree is a data structure used to make spacial computation and comparison much faster than brute force.  ...

\section{Use Cases}
The R-tree is very similar to the B-tree in structure, and Quad-Tree in use. One of the main differences is that
R-trees are page-able. This means that they could be put into storage, which could be ideal for very large data sets
that can't be stored in ram. You can also take out parts of the R-tree into ram while working with it. A good example
of a program that could use R-trees is a mapping system of the world, where the large data set would be hard to store in memory.
The R-tree is also very good for nearest neighbor searching. Also R-tree can be used to store any type of shape which allow for shapes
of things such as buildings to be put in the minimum bounding rectangle. R-trees have also been used a lot in databases for spacial data.


\section{Inserting}
Complexity

average : none

worst case : $O(n)$

When splitting we are trying to find the best leaf node
that will have least increase to the minimum bounding rectangle that it is inserted in.
It should also be noted that when we are at M entries at the inserted leaf node, we
need to split.

\usetikzlibrary{shapes}
\begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=45mm]
    \tikzstyle{level 2}=[sibling distance=20mm]
    \node {$N_1$} [->]
    child {node {$N_2$ \nodepart{two} $N_3$}
    child {node {$N_6$ \nodepart{two} $N_7$}}
    child {node {$N_8$ \nodepart{two} $N_9$}}    
  } 
  child {node {$N_4$ \nodepart{two} $N_5$}
        child {node {$N_{10}$ \nodepart{two} $N_{11}$}}
    child {node {$N_{12}$ \nodepart{two} $N_{13}$}} 
  };
    
\end{tikzpicture}


In this figure we would be adding the node G as a child of G
if C's minimum boudning box increases the least.

Note: In this example the leaf nodes are the actual points, you would normaly store these in a array.
\subsection*{Psuedo Code}
\begin{flushleft}
    
If at leaf:

\quad Insert Entry

\quad If(entries $>$ M):

\quad \quad Split();

\quad CurrentNode.entries.Add(Entry);

\quad return;


For(each child):


\quad If(ChildNode.IsEngulf(Entry)):

 \quad \quad Insert(Node);


else:

\quad For(each child):

    \quad \quad
    Find difference in area if Entry were inserted

    \quad insert(NodeWithSmallestDifference);
\end{flushleft}

\section{Splitting} 

\section{Searching}
Complexity
Average : $O(log_Mn)$
Worst Case : $O(n)$

\section{Removing}
\paragraph{}
When removing a point - or an object - from a R Tree, the first step is to find the leaf node that stores the point.
However, we have already covered that in the previous section, Searching. Now that we have the leaf node that contains
the point, we now remove the point from the leaf node. This may reduce the number of entries this leaf node has to be below
$M/2$, which is not allowed for nodes that are not root. If the leaf node is the root then we ignore this problem, because
we can't have a smaller tree.
\begin{tikzpicture}
    \node{rest of the tree}
        child {node{parent} child{node{leaf} } child{node{other leaf}} };
\end{tikzpicture}

\paragraph{}
If this node is not the root and has less than $M/2$ entries, then it is necessary to delete that node. But we don't want to destroy
the other $M/2 - 1$ nodes, so we'll store each of the node's entries into a list, or other container type, to insert back into
the tree when we are done removing. Because we are removing the leaf node, this means that its parent's entries can also fall below
$M/2$ nodes, which then requires that it is deleted too. In that case, a recursive search of all of that parent's children is necessary
to find all points - or other data objects - to store for reinsertion later.
\paragraph{}
Even though it seems that a the leaf node case and the parent node case seem different, they are actually the same case. Parents have
other nodes as their entries and leaf nodes have objects as their entries. Both must have $M/2 \le n \le M$ entries (where $n$ is the number
of entries the node has), and both need to be deleted from their parent and recursively store all of the entries below it in the tree.

\section{Citation}

% text \textbf{bold text} text. Some math: $2+2=5$

% \begin{tikzpicture}[main/.style = {draw, circle}]
% \node[main](1){$x_1$};
% \end{tikzpicture}

\end{document}